{"version":3,"sources":["gl/common.js","gl/c2/index.js","gl/App.js","serviceWorker.js","index.js","gl/c2/vertex.glsl","gl/c2/fragment.glsl"],"names":["createShader","gl","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","deleteShader","c","canvas","image","Image","src","process","onload","getContext","vertexShader","VERTEX_SHADER","vertexShaderSource","fragmentShader","FRAGMENT_SHADER","fragmentShaderSource","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","useProgram","positionLocation","getAttribLocation","texcoordLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","x","y","width","height","x1","x2","y1","y2","bufferData","Float32Array","STATIC_DRAW","setRectangle","texcoordBuffer","texture","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","resolutionLocation","getUniformLocation","viewport","clearColor","clear","COLOR_BUFFER_BIT","enableVertexAttribArray","FLOAT","vertexAttribPointer","uniform2f","primitiveType","TRIANGLES","drawArrays","render","WebGl","react_default","a","createElement","App_WebGlCanvas","initcanvas","Component","WebGlCanvas","this","props","style","border","ref","id","Boolean","window","location","hostname","match","ReactDOM","App_WebGl","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports"],"mappings":"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","file":"static/js/main.fc80bbcb.chunk.js","sourcesContent":["\n// 创建着色器方法，输入参数：渲染上下文，着色器类型，数据源\nexport function createShader(gl, type, source) {\n  var shader = gl.createShader(type); // 创建着色器对象\n  gl.shaderSource(shader, source); // 提供数据源\n  gl.compileShader(shader); // 编译 -> 生成着色器\n  var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (success) {\n    return shader;\n  }\n \n  console.log(gl.getShaderInfoLog(shader));\n  gl.deleteShader(shader);\n}\n\nexport function createProgram(gl, vertexShader, fragmentShader) {\n  var program = gl.createProgram();\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  var success = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (success) {\n    return program;\n  }\n \n  console.log(gl.getProgramInfoLog(program));\n  gl.deleteProgram(program);\n}","import { createProgram, createShader } from '../common.js';\nimport vertexShaderSource from './vertex.glsl';\nimport fragmentShaderSource from './fragment.glsl';\n\n\nexport default function c(canvas) {\n  var image = new Image();\n  image.src = process.env.PUBLIC_URL + \"/leaves.jpg\";\n  image.onload = function() {\n    render(canvas, image);\n  };\n}\n\nexport function render(canvas, image) {\n  console.log(process.env)\n  const gl = canvas.getContext('webgl');\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  var program = createProgram(gl, vertexShader, fragmentShader);\n  gl.useProgram(program);\n\n  const positionLocation = gl.getAttribLocation(program, \"a_position\");\n  const texcoordLocation = gl.getAttribLocation(program, 'a_texCoord');\n  var positionBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n  setRectangle(gl, 0, 0, image.width, image.height);\n\n  var texcoordBuffer = gl.createBuffer();\n  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n      0.0,  0.0,\n      1.0,  0.0,\n      0.0,  1.0,\n      0.0,  1.0,\n      1.0,  0.0,\n      1.0,  1.0,\n  ]), gl.STATIC_DRAW);\n\n  var texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\n  var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n\n\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n  gl.clearColor(0, 0, 0, 0);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n\n  gl.useProgram(program);\n\n  gl.enableVertexAttribArray(positionLocation);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n  var size = 2;\n  var type = gl.FLOAT;\n  var normalize = false;\n  var stride = 0;\n  var offset = 0;\n  gl.vertexAttribPointer(\n      positionLocation, size, type, normalize, stride, offset);\n\n  gl.enableVertexAttribArray(texcoordLocation);\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\n  gl.vertexAttribPointer(\n      texcoordLocation, size, type, normalize, stride, offset);\n\n  gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);\n\n  var primitiveType = gl.TRIANGLES;\n  var count = 6;\n  gl.drawArrays(primitiveType, 0, count);\n\n}\n\nfunction setRectangle(gl, x, y, width, height) {\n  var x1 = x;\n  var x2 = x + width;\n  var y1 = y;\n  var y2 = y + height;\n  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n     x1, y1,\n     x2, y1,\n     x1, y2,\n     x1, y2,\n     x2, y1,\n     x2, y2,\n  ]), gl.STATIC_DRAW);\n}","import React, { Component } from 'react';\nimport c from './c2'\nexport default class WebGl extends Component {\n  render() {\n    return <div>\n      <WebGlCanvas initcanvas={c} />\n    </div>\n  }\n}\n\n\nclass WebGlCanvas extends Component {\n  render() {\n    const { initcanvas } = this.props;\n    return <div>\n      <canvas\n        style={{\n          border: '1px solid'\n        }}\n        ref={(c) => {\n          if (!c) return;\n          initcanvas(c);\n        }}\n        id=\"canvas-ex\"\n        width=\"400\"\n        height=\"400\"\n      >\n        canvas\n      </canvas>\n    </div>\n  }\n}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './gl/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = \"attribute vec2 a_position;\\nattribute vec2 a_texCoord;\\n\\nuniform vec2 u_resolution;\\n\\nvarying vec2 v_texCoord;\\n\\nvoid main() {\\n   // convert the rectangle from pixels to 0.0 to 1.0\\n   vec2 zeroToOne = a_position / u_resolution;\\n\\n   // convert from 0->1 to 0->2\\n   vec2 zeroToTwo = zeroToOne * 2.0;\\n\\n   // convert from 0->2 to -1->+1 (clipspace)\\n   vec2 clipSpace = zeroToTwo - 1.0;\\n\\n   gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\\n\\n   // pass the texCoord to the fragment shader\\n   // The GPU will interpolate this value between points.\\n   v_texCoord = a_texCoord;\\n}\\n\"","module.exports = \"precision mediump float;\\n// 纹理\\nuniform sampler2D u_image;\\n \\n// 从顶点着色器传入的纹理坐标\\nvarying vec2 v_texCoord;\\n \\nvoid main() {\\n   // 在纹理上寻找对应颜色值\\n   gl_FragColor = texture2D(u_image, v_texCoord);\\n}\""],"sourceRoot":""}